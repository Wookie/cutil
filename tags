!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
1	coverage/cutil/src/aiofd.c.gcov.html	/^<a name="1"><span class="lineNum">       1 <\/span>                :            : \/*<\/a>$/;"	a
1	coverage/cutil/src/array.c.gcov.html	/^<a name="1"><span class="lineNum">       1 <\/span>                :            : \/*<\/a>$/;"	a
1	coverage/cutil/src/bitset.c.gcov.html	/^<a name="1"><span class="lineNum">       1 <\/span>                :            : \/*<\/a>$/;"	a
1	coverage/cutil/src/btree.c.gcov.html	/^<a name="1"><span class="lineNum">       1 <\/span>                :            : \/*<\/a>$/;"	a
1	coverage/cutil/src/buffer.c.gcov.html	/^<a name="1"><span class="lineNum">       1 <\/span>                :            : \/*<\/a>$/;"	a
1	coverage/cutil/src/child.c.gcov.html	/^<a name="1"><span class="lineNum">       1 <\/span>                :            : \/*<\/a>$/;"	a
1	coverage/cutil/src/events.c.gcov.html	/^<a name="1"><span class="lineNum">       1 <\/span>                :            : \/*<\/a>$/;"	a
1	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="1"><span class="lineNum">       1 <\/span>                :            : \/*<\/a>$/;"	a
1	coverage/cutil/src/pair.c.gcov.html	/^<a name="1"><span class="lineNum">       1 <\/span>                :            : \/*<\/a>$/;"	a
1	coverage/cutil/src/privileges.c.gcov.html	/^<a name="1"><span class="lineNum">       1 <\/span>                :            : \/*<\/a>$/;"	a
1	coverage/cutil/src/sanitize.c.gcov.html	/^<a name="1"><span class="lineNum">       1 <\/span>                :            : \/*<\/a>$/;"	a
104	coverage/cutil/src/array.c.gcov.html	/^<a name="104"><span class="lineNum">     104 <\/span>                :            :  * data structure is deleted.<\/a>$/;"	a
105	coverage/cutil/src/bitset.c.gcov.html	/^<a name="105"><span class="lineNum">     105 <\/span>                :            : }<\/a>$/;"	a
105	coverage/cutil/src/events.c.gcov.html	/^<a name="105"><span class="lineNum">     105 <\/span>                :<span class="lineNoCov">          0 : }<\/span><\/a>$/;"	a
1054	coverage/cutil/src/btree.c.gcov.html	/^<a name="1054"><span class="lineNum">    1054 <\/span>                :            : }<\/a>$/;"	a
1070	coverage/cutil/src/btree.c.gcov.html	/^<a name="1070"><span class="lineNum">    1070 <\/span>                :            : }<\/a>$/;"	a
1081	coverage/cutil/src/btree.c.gcov.html	/^<a name="1081"><span class="lineNum">    1081 <\/span>                :            : static const bt_itr_t itr_end = NULL;<\/a>$/;"	a
1089	coverage/cutil/src/btree.c.gcov.html	/^<a name="1089"><span class="lineNum">    1089 <\/span>                :            : <\/a>$/;"	a
1100	coverage/cutil/src/btree.c.gcov.html	/^<a name="1100"><span class="lineNum">    1100 <\/span>                :            : <\/a>$/;"	a
1106	coverage/cutil/src/btree.c.gcov.html	/^<a name="1106"><span class="lineNum">    1106 <\/span>                :            : <\/a>$/;"	a
1114	coverage/cutil/src/btree.c.gcov.html	/^<a name="1114"><span class="lineNum">    1114 <\/span>                :            : <\/a>$/;"	a
1125	coverage/cutil/src/btree.c.gcov.html	/^<a name="1125"><span class="lineNum">    1125 <\/span>                :            : <\/a>$/;"	a
1131	coverage/cutil/src/btree.c.gcov.html	/^<a name="1131"><span class="lineNum">    1131 <\/span>                :            : <\/a>$/;"	a
1140	coverage/cutil/src/btree.c.gcov.html	/^<a name="1140"><span class="lineNum">    1140 <\/span>                :            : }<\/a>$/;"	a
116	coverage/cutil/src/child.c.gcov.html	/^<a name="116"><span class="lineNum">     116 <\/span>                :            : <\/a>$/;"	a
118	coverage/cutil/src/btree.c.gcov.html	/^<a name="118"><span class="lineNum">     118 <\/span>                :            : #endif<\/a>$/;"	a
122	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="122"><span class="lineNum">     122 <\/span>                :            : <\/a>$/;"	a
124	coverage/cutil/src/aiofd.c.gcov.html	/^<a name="124"><span class="lineNum">     124 <\/span>                :            : <\/a>$/;"	a
128	coverage/cutil/src/child.c.gcov.html	/^<a name="128"><span class="lineNum">     128 <\/span>                :            : <\/a>$/;"	a
128	coverage/cutil/src/events.c.gcov.html	/^<a name="128"><span class="lineNum">     128 <\/span>                :            : }<\/a>$/;"	a
146	coverage/cutil/src/events.c.gcov.html	/^<a name="146"><span class="lineNum">     146 <\/span>                :            : }<\/a>$/;"	a
150	coverage/cutil/src/btree.c.gcov.html	/^<a name="150"><span class="lineNum">     150 <\/span>                :            : }<\/a>$/;"	a
154	coverage/cutil/src/child.c.gcov.html	/^<a name="154"><span class="lineNum">     154 <\/span>                :            : <\/a>$/;"	a
155	coverage/cutil/src/array.c.gcov.html	/^<a name="155"><span class="lineNum">     155 <\/span>                :            :  * initializes it.<\/a>$/;"	a
157	coverage/cutil/src/events.c.gcov.html	/^<a name="157"><span class="lineNum">     157 <\/span>                :            : <\/a>$/;"	a
160	coverage/cutil/src/btree.c.gcov.html	/^<a name="160"><span class="lineNum">     160 <\/span>                :            : }<\/a>$/;"	a
164	coverage/cutil/src/aiofd.c.gcov.html	/^<a name="164"><span class="lineNum">     164 <\/span>                :            : <\/a>$/;"	a
175	coverage/cutil/src/btree.c.gcov.html	/^<a name="175"><span class="lineNum">     175 <\/span>                :            : <\/a>$/;"	a
180	coverage/cutil/src/array.c.gcov.html	/^<a name="180"><span class="lineNum">     180 <\/span>                :            :  * then nothing will be done to clean up each node.<\/a>$/;"	a
181	coverage/cutil/src/child.c.gcov.html	/^<a name="181"><span class="lineNum">     181 <\/span>                :            : <\/a>$/;"	a
186	coverage/cutil/src/aiofd.c.gcov.html	/^<a name="186"><span class="lineNum">     186 <\/span>                :            : }<\/a>$/;"	a
192	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="192"><span class="lineNum">     192 <\/span>                :            : \/* NOTE: If NULL is passed in for the key_eq_fn function, the default<\/a>$/;"	a
196	coverage/cutil/src/aiofd.c.gcov.html	/^<a name="196"><span class="lineNum">     196 <\/span>                :            : }<\/a>$/;"	a
209	coverage/cutil/src/events.c.gcov.html	/^<a name="209"><span class="lineNum">     209 <\/span>                :            : <\/a>$/;"	a
215	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="215"><span class="lineNum">     215 <\/span>                :            : }<\/a>$/;"	a
223	coverage/cutil/src/btree.c.gcov.html	/^<a name="223"><span class="lineNum">     223 <\/span>                :            : \/* NOTE: If NULL is passed in for the bt_key_cmp_fn function, the default<\/a>$/;"	a
229	coverage/cutil/src/events.c.gcov.html	/^<a name="229"><span class="lineNum">     229 <\/span>                :            : }<\/a>$/;"	a
23	coverage/cutil/src/bitset.c.gcov.html	/^<a name="23"><span class="lineNum">      23 <\/span>                :            : #define BIT(x) ((uint32_t)(1 &lt;&lt; (x &amp; 0x1f)))<\/a>$/;"	a
238	coverage/cutil/src/events.c.gcov.html	/^<a name="238"><span class="lineNum">     238 <\/span>                :<span class="lineCov">        640 : }<\/span><\/a>$/;"	a
245	coverage/cutil/src/array.c.gcov.html	/^<a name="245"><span class="lineNum">     245 <\/span>                :            : <\/a>$/;"	a
246	coverage/cutil/src/btree.c.gcov.html	/^<a name="246"><span class="lineNum">     246 <\/span>                :            : <\/a>$/;"	a
249	coverage/cutil/src/events.c.gcov.html	/^<a name="249"><span class="lineNum">     249 <\/span>                :            : };<\/a>$/;"	a
25	coverage/cutil/src/pair.c.gcov.html	/^<a name="25"><span class="lineNum">      25 <\/span>                :            : };<\/a>$/;"	a
259	coverage/cutil/src/array.c.gcov.html	/^<a name="259"><span class="lineNum">     259 <\/span>                :            : <\/a>$/;"	a
26	coverage/cutil/src/buffer.c.gcov.html	/^<a name="26"><span class="lineNum">      26 <\/span>                :            : };<\/a>$/;"	a
262	coverage/cutil/src/aiofd.c.gcov.html	/^<a name="262"><span class="lineNum">     262 <\/span>                :            : }<\/a>$/;"	a
271	coverage/cutil/src/array.c.gcov.html	/^<a name="271"><span class="lineNum">     271 <\/span>                :            :  * buffer to the new buffer, compacting them at the same time<\/a>$/;"	a
273	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="273"><span class="lineNum">     273 <\/span>                :            : <\/a>$/;"	a
274	coverage/cutil/src/aiofd.c.gcov.html	/^<a name="274"><span class="lineNum">     274 <\/span>                :<span class="lineCov">        256 : }<\/span><\/a>$/;"	a
28	coverage/cutil/src/events.c.gcov.html	/^<a name="28"><span class="lineNum">      28 <\/span>                :            : <\/a>$/;"	a
286	coverage/cutil/src/events.c.gcov.html	/^<a name="286"><span class="lineNum">     286 <\/span>                :            : }<\/a>$/;"	a
288	coverage/cutil/src/btree.c.gcov.html	/^<a name="288"><span class="lineNum">     288 <\/span>                :            : <\/a>$/;"	a
289	coverage/cutil/src/child.c.gcov.html	/^<a name="289"><span class="lineNum">     289 <\/span>                :            : }<\/a>$/;"	a
289	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="289"><span class="lineNum">     289 <\/span>                :            : <\/a>$/;"	a
290	coverage/cutil/src/aiofd.c.gcov.html	/^<a name="290"><span class="lineNum">     290 <\/span>                :            : }<\/a>$/;"	a
302	coverage/cutil/src/btree.c.gcov.html	/^<a name="302"><span class="lineNum">     302 <\/span>                :            : <\/a>$/;"	a
303	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="303"><span class="lineNum">     303 <\/span>                :            : <\/a>$/;"	a
306	coverage/cutil/src/aiofd.c.gcov.html	/^<a name="306"><span class="lineNum">     306 <\/span>                :            : }<\/a>$/;"	a
309	coverage/cutil/src/btree.c.gcov.html	/^<a name="309"><span class="lineNum">     309 <\/span>                :            : }<\/a>$/;"	a
312	coverage/cutil/src/child.c.gcov.html	/^<a name="312"><span class="lineNum">     312 <\/span>                :            : }<\/a>$/;"	a
313	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="313"><span class="lineNum">     313 <\/span>                :            : \/* returns the current fraction of how full the hash table is.<\/a>$/;"	a
320	coverage/cutil/src/btree.c.gcov.html	/^<a name="320"><span class="lineNum">     320 <\/span>                :            : }<\/a>$/;"	a
321	coverage/cutil/src/events.c.gcov.html	/^<a name="321"><span class="lineNum">     321 <\/span>                :            : <\/a>$/;"	a
329	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="329"><span class="lineNum">     329 <\/span>                :            : \/* returns the load limit that will trigger a resize when the <\/a>$/;"	a
33	coverage/cutil/src/privileges.c.gcov.html	/^<a name="33"><span class="lineNum">      33 <\/span>                :            : static gid_t orig_groups[NGROUPS_MAX];<\/a>$/;"	a
331	coverage/cutil/src/events.c.gcov.html	/^<a name="331"><span class="lineNum">     331 <\/span>                :            : }<\/a>$/;"	a
335	coverage/cutil/src/child.c.gcov.html	/^<a name="335"><span class="lineNum">     335 <\/span>                :            : }<\/a>$/;"	a
337	coverage/cutil/src/aiofd.c.gcov.html	/^<a name="337"><span class="lineNum">     337 <\/span>                :            : <\/a>$/;"	a
339	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="339"><span class="lineNum">     339 <\/span>                :            :  * NOTE: it only supports keeping the table the same size (compacting)<\/a>$/;"	a
346	coverage/cutil/src/child.c.gcov.html	/^<a name="346"><span class="lineNum">     346 <\/span>                :            : }<\/a>$/;"	a
35	coverage/cutil/src/pair.c.gcov.html	/^<a name="35"><span class="lineNum">      35 <\/span>                :            : }<\/a>$/;"	a
352	coverage/cutil/src/child.c.gcov.html	/^<a name="352"><span class="lineNum">     352 <\/span>                :            : }<\/a>$/;"	a
356	coverage/cutil/src/array.c.gcov.html	/^<a name="356"><span class="lineNum">     356 <\/span>                :            : <\/a>$/;"	a
36	coverage/cutil/src/bitset.c.gcov.html	/^<a name="36"><span class="lineNum">      36 <\/span>                :            : }<\/a>$/;"	a
362	coverage/cutil/src/child.c.gcov.html	/^<a name="362"><span class="lineNum">     362 <\/span>                :            : }<\/a>$/;"	a
37	coverage/cutil/src/aiofd.c.gcov.html	/^<a name="37"><span class="lineNum">      37 <\/span>                :            : <\/a>$/;"	a
370	coverage/cutil/src/child.c.gcov.html	/^<a name="370"><span class="lineNum">     370 <\/span>                :            : }<\/a>$/;"	a
374	coverage/cutil/src/aiofd.c.gcov.html	/^<a name="374"><span class="lineNum">     374 <\/span>                :            : }<\/a>$/;"	a
378	coverage/cutil/src/child.c.gcov.html	/^<a name="378"><span class="lineNum">     378 <\/span>                :            : }<\/a>$/;"	a
38	coverage/cutil/src/buffer.c.gcov.html	/^<a name="38"><span class="lineNum">      38 <\/span>                :            : }<\/a>$/;"	a
38	coverage/cutil/src/sanitize.c.gcov.html	/^<a name="38"><span class="lineNum">      38 <\/span>                :            : #endif<\/a>$/;"	a
381	coverage/cutil/src/aiofd.c.gcov.html	/^<a name="381"><span class="lineNum">     381 <\/span>                :            : }<\/a>$/;"	a
388	coverage/cutil/src/btree.c.gcov.html	/^<a name="388"><span class="lineNum">     388 <\/span>                :            : }<\/a>$/;"	a
397	coverage/cutil/src/aiofd.c.gcov.html	/^<a name="397"><span class="lineNum">     397 <\/span>                :            : }<\/a>$/;"	a
404	coverage/cutil/src/array.c.gcov.html	/^<a name="404"><span class="lineNum">     404 <\/span>                :            : <\/a>$/;"	a
427	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="427"><span class="lineNum">     427 <\/span>                :            :  * factor less than the limit.  if the table does not need to grow<\/a>$/;"	a
43	coverage/cutil/src/pair.c.gcov.html	/^<a name="43"><span class="lineNum">      43 <\/span>                :            : }<\/a>$/;"	a
434	coverage/cutil/src/array.c.gcov.html	/^<a name="434"><span class="lineNum">     434 <\/span>                :            : <\/a>$/;"	a
446	coverage/cutil/src/array.c.gcov.html	/^<a name="446"><span class="lineNum">     446 <\/span>                :            : <\/a>$/;"	a
452	coverage/cutil/src/array.c.gcov.html	/^<a name="452"><span class="lineNum">     452 <\/span>                :            : <\/a>$/;"	a
457	coverage/cutil/src/btree.c.gcov.html	/^<a name="457"><span class="lineNum">     457 <\/span>                :            : }<\/a>$/;"	a
46	coverage/cutil/src/bitset.c.gcov.html	/^<a name="46"><span class="lineNum">      46 <\/span>                :            : }<\/a>$/;"	a
465	coverage/cutil/src/array.c.gcov.html	/^<a name="465"><span class="lineNum">     465 <\/span>                :            : <\/a>$/;"	a
473	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="473"><span class="lineNum">     473 <\/span>                :            : \/* set the load limit that will trigger a resize.  this defaults<\/a>$/;"	a
479	coverage/cutil/src/array.c.gcov.html	/^<a name="479"><span class="lineNum">     479 <\/span>                :            : }<\/a>$/;"	a
49	coverage/cutil/src/pair.c.gcov.html	/^<a name="49"><span class="lineNum">      49 <\/span>                :            : }<\/a>$/;"	a
498	coverage/cutil/src/array.c.gcov.html	/^<a name="498"><span class="lineNum">     498 <\/span>                :            :  * array_itr_end() function.<\/a>$/;"	a
50	coverage/cutil/src/child.c.gcov.html	/^<a name="50"><span class="lineNum">      50 <\/span>                :            : };<\/a>$/;"	a
512	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="512"><span class="lineNum">     512 <\/span>                :            :  * the filler nodes and &quot;compacts&quot; the table.  use this to keep your<\/a>$/;"	a
53	coverage/cutil/src/events.c.gcov.html	/^<a name="53"><span class="lineNum">      53 <\/span>                :            : <\/a>$/;"	a
539	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="539"><span class="lineNum">     539 <\/span>                :            : \/* NOTE: if the number of values stored in the table will exceed a load <\/a>$/;"	a
552	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="552"><span class="lineNum">     552 <\/span>                :            : }<\/a>$/;"	a
554	coverage/cutil/src/array.c.gcov.html	/^<a name="554"><span class="lineNum">     554 <\/span>                :            : <\/a>$/;"	a
571	coverage/cutil/src/btree.c.gcov.html	/^<a name="571"><span class="lineNum">     571 <\/span>                :            : }<\/a>$/;"	a
58	coverage/cutil/src/sanitize.c.gcov.html	/^<a name="58"><span class="lineNum">      58 <\/span>                :            : }<\/a>$/;"	a
59	coverage/cutil/src/bitset.c.gcov.html	/^<a name="59"><span class="lineNum">      59 <\/span>                :            : }<\/a>$/;"	a
609	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="609"><span class="lineNum">     609 <\/span>                :            : <\/a>$/;"	a
622	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="622"><span class="lineNum">     622 <\/span>                :            : <\/a>$/;"	a
632	coverage/cutil/src/array.c.gcov.html	/^<a name="632"><span class="lineNum">     632 <\/span>                :            : <\/a>$/;"	a
648	coverage/cutil/src/array.c.gcov.html	/^<a name="648"><span class="lineNum">     648 <\/span>                :            : <\/a>$/;"	a
660	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="660"><span class="lineNum">     660 <\/span>                :            : <\/a>$/;"	a
672	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="672"><span class="lineNum">     672 <\/span>                :            : }<\/a>$/;"	a
676	coverage/cutil/src/array.c.gcov.html	/^<a name="676"><span class="lineNum">     676 <\/span>                :            : <\/a>$/;"	a
686	coverage/cutil/src/btree.c.gcov.html	/^<a name="686"><span class="lineNum">     686 <\/span>                :            : <\/a>$/;"	a
695	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="695"><span class="lineNum">     695 <\/span>                :            : <\/a>$/;"	a
70	coverage/cutil/src/bitset.c.gcov.html	/^<a name="70"><span class="lineNum">      70 <\/span>                :            : }<\/a>$/;"	a
71	coverage/cutil/src/btree.c.gcov.html	/^<a name="71"><span class="lineNum">      71 <\/span>                :            : <\/a>$/;"	a
71	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="71"><span class="lineNum">      71 <\/span>                :            : <\/a>$/;"	a
725	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="725"><span class="lineNum">     725 <\/span>                :            : <\/a>$/;"	a
733	coverage/cutil/src/array.c.gcov.html	/^<a name="733"><span class="lineNum">     733 <\/span>                :            : }<\/a>$/;"	a
734	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="734"><span class="lineNum">     734 <\/span>                :            : }<\/a>$/;"	a
740	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="740"><span class="lineNum">     740 <\/span>                :            : }<\/a>$/;"	a
745	coverage/cutil/src/array.c.gcov.html	/^<a name="745"><span class="lineNum">     745 <\/span>                :            : }<\/a>$/;"	a
750	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="750"><span class="lineNum">     750 <\/span>                :            : }<\/a>$/;"	a
768	coverage/cutil/src/btree.c.gcov.html	/^<a name="768"><span class="lineNum">     768 <\/span>                :            : <\/a>$/;"	a
769	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="769"><span class="lineNum">     769 <\/span>                :            : }<\/a>$/;"	a
78	coverage/cutil/src/bitset.c.gcov.html	/^<a name="78"><span class="lineNum">      78 <\/span>                :            : }<\/a>$/;"	a
78	coverage/cutil/src/child.c.gcov.html	/^<a name="78"><span class="lineNum">      78 <\/span>                :            : <\/a>$/;"	a
78	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="78"><span class="lineNum">      78 <\/span>                :            : \/* the default key compare function just casts the pointers to uint_t<\/a>$/;"	a
788	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="788"><span class="lineNum">     788 <\/span>                :            : }<\/a>$/;"	a
80	coverage/cutil/src/events.c.gcov.html	/^<a name="80"><span class="lineNum">      80 <\/span>                :            : <\/a>$/;"	a
807	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="807"><span class="lineNum">     807 <\/span>                :            : #ifdef UNIT_TESTING<\/a>$/;"	a
816	coverage/cutil/src/hashtable.c.gcov.html	/^<a name="816"><span class="lineNum">     816 <\/span>                :            : }<\/a>$/;"	a
845	coverage/cutil/src/btree.c.gcov.html	/^<a name="845"><span class="lineNum">     845 <\/span>                :            : \/* NOTE: if the number of values stored in the table will exceed a load <\/a>$/;"	a
86	coverage/cutil/src/bitset.c.gcov.html	/^<a name="86"><span class="lineNum">      86 <\/span>                :            : }<\/a>$/;"	a
866	coverage/cutil/src/btree.c.gcov.html	/^<a name="866"><span class="lineNum">     866 <\/span>                :            : <\/a>$/;"	a
89	coverage/cutil/src/privileges.c.gcov.html	/^<a name="89"><span class="lineNum">      89 <\/span>                :<span class="lineCov">        128 : }<\/span><\/a>$/;"	a
892	coverage/cutil/src/btree.c.gcov.html	/^<a name="892"><span class="lineNum">     892 <\/span>                :            : }<\/a>$/;"	a
904	coverage/cutil/src/btree.c.gcov.html	/^<a name="904"><span class="lineNum">     904 <\/span>                :            : }<\/a>$/;"	a
917	coverage/cutil/src/btree.c.gcov.html	/^<a name="917"><span class="lineNum">     917 <\/span>                :            : <\/a>$/;"	a
93	coverage/cutil/src/bitset.c.gcov.html	/^<a name="93"><span class="lineNum">      93 <\/span>                :            : }<\/a>$/;"	a
930	coverage/cutil/src/btree.c.gcov.html	/^<a name="930"><span class="lineNum">     930 <\/span>                :            : }<\/a>$/;"	a
99	coverage/cutil/src/sanitize.c.gcov.html	/^<a name="99"><span class="lineNum">      99 <\/span>                :            : };<\/a>$/;"	a
991	coverage/cutil/src/btree.c.gcov.html	/^<a name="991"><span class="lineNum">     991 <\/span>                :            : <\/a>$/;"	a
ACTIVE	src/hashtable.c	69;"	d	file:
ADD_SUITE	tests/test_all.c	32;"	d	file:
ARRAY_SIZE	src/macros.h	35;"	d
ASSERT	src/macros.h	38;"	d
BIT	src/bitset.c	23;"	d	file:
BUILDDIRS	Makefile	/^BUILDDIRS = $(DIRS:%=build-%)$/;"	m
C	src/macros.h	67;"	d
CALLOC	src/macros.h	56;"	d
CFLAGS	src/Makefile	/^CFLAGS=-O3$/;"	m
CFLAGS	src/Makefile	/^coverage: CFLAGS=-fprofile-arcs -ftest-coverage -O0 -gstabs+ -DUNIT_TESTING$/;"	m
CFLAGS	src/Makefile	/^test: CFLAGS=-O0 -gstabs+ -DUNIT_TESTING$/;"	m
CFLAGS	tests/Makefile	/^CFLAGS=-O0 -gstabs+ -I$(CUTIL_ROOT)\/include -I$(EXTRA_LIBS_ROOT)\/include$/;"	m
CHECK	src/macros.h	45;"	d
CHECK_MSG	src/macros.h	46;"	d
CHECK_PTR	src/macros.h	49;"	d
CHECK_PTR_MSG	src/macros.h	50;"	d
CHECK_PTR_RET	src/macros.h	51;"	d
CHECK_PTR_RET_MSG	src/macros.h	52;"	d
CHECK_RET	src/macros.h	47;"	d
CHECK_RET_MSG	src/macros.h	48;"	d
CLEANDIRS	Makefile	/^CLEANDIRS = $(DIRS:%=clean-%)$/;"	m
COVERAGE	Makefile	/^COVERAGE?=.\/coverage$/;"	m
COVERAGE	src/Makefile	/^COVERAGE?=..\/coverage$/;"	m
CUTIL_ROOT	tests/Makefile	/^CUTIL_ROOT=..\/src$/;"	m
DEBUG	src/debug.h	17;"	d
DEBUG	src/debug.h	20;"	d
DEBUG	src/debug.h	22;"	d
DEBUG_ON	src/debug.h	25;"	d
DEFAULT_INITIAL_CAPACITY	src/array.c	27;"	d	file:
DEFAULT_INITIAL_CAPACITY	src/btree.c	31;"	d	file:
DELETED	src/hashtable.c	70;"	d	file:
DIRS	Makefile	/^DIRS = src tests$/;"	m
DWORDS_NEEDED	src/bitset.c	21;"	d	file:
DWORD_INDEX	src/bitset.c	22;"	d	file:
EMPTY	src/hashtable.c	68;"	d	file:
EMPTY_ENV	src/child.h	24;"	d
EVT_BAD_PTR	src/events.h	/^	EVT_BAD_PTR = -1,$/;"	e	enum:evt_ret_e
EVT_CHILD	src/events.h	/^	EVT_CHILD,$/;"	e	enum:evt_type_e
EVT_ERROR	src/events.h	/^	EVT_ERROR = -2$/;"	e	enum:evt_ret_e
EVT_IO	src/events.h	/^	EVT_IO$/;"	e	enum:evt_type_e
EVT_IO_READ	src/events.h	/^	EVT_IO_READ =  0x01,$/;"	e	enum:evt_io_type_e
EVT_IO_WRITE	src/events.h	/^	EVT_IO_WRITE = 0x02$/;"	e	enum:evt_io_type_e
EVT_OK	src/events.h	/^	EVT_OK = 1,$/;"	e	enum:evt_ret_e
EVT_SIGNAL	src/events.h	/^	EVT_SIGNAL,$/;"	e	enum:evt_type_e
EV_MULTIPLICITY	src/events.c	18;"	d	file:
EV_STANDALONE	src/events.c	17;"	d	file:
EXTRA_LIBS_ROOT	tests/Makefile	/^EXTRA_LIBS_ROOT=\/usr\/local$/;"	m
FAIL	src/macros.h	42;"	d
FALSE	src/macros.h	31;"	d
FREE	src/macros.h	58;"	d
GCDA	src/Makefile	/^GCDA=$(SRC:.c=.gcda)$/;"	m
GCDA	tests/Makefile	/^GCDA=$(SRC:.c=.gcda)$/;"	m
GCNO	src/Makefile	/^GCNO=$(SRC:.c=.gcno)$/;"	m
GCNO	tests/Makefile	/^GCNO=$(SRC:.c=.gcno)$/;"	m
GCOV	src/Makefile	/^GCOV=$(SRC:.c=.c.gcov)$/;"	m
GCOV	tests/Makefile	/^GCOV=$(SRC:.c=.c.gcov)$/;"	m
GCOVDIRS	Makefile	/^GCOVDIRS = $(DIRS:%=gcov-%)$/;"	m
HDR	src/Makefile	/^HDR=aiofd.h array.h  bitset.h btree.h buffer.h child.h daemon.h debug.h events.h hashtable.h log.h macros.h pair.h privileges.h sanitize.h socket.h$/;"	m
INSTALL	Makefile	/^INSTALL=\/usr\/bin\/install$/;"	m
INSTALL	src/Makefile	/^INSTALL=\/usr\/bin\/install$/;"	m
INSTALLDIRS	Makefile	/^INSTALLDIRS = $(DIRS:%=install-%)$/;"	m
INSTALL_DATA	Makefile	/^INSTALL_DATA=$(INSTALL) -m 644$/;"	m
INSTALL_DATA	src/Makefile	/^INSTALL_DATA=$(INSTALL) -m 644$/;"	m
INSTALL_PROGRAM	Makefile	/^INSTALL_PROGRAM=$(INSTALL)$/;"	m
INSTALL_PROGRAM	src/Makefile	/^INSTALL_PROGRAM=$(INSTALL)$/;"	m
IPv4	src/socket.h	/^typedef struct in_addr IPv4;$/;"	t	typeref:struct:in_addr
LDFLAGS	tests/Makefile	/^LDFLAGS=-O0 -gstabs+ -L$(CUTIL_ROOT)\/lib -L$(EXTRA_LIBS_ROOT)\/lib$/;"	m
LDFLAGS	tests/Makefile	/^coverage: LDFLAGS=-fprofile-arcs -O0 -gstabs+ -L$(CUTIL_ROOT)\/lib -L$(EXTRA_LIBS_ROOT)\/lib$/;"	m
LIBS	tests/Makefile	/^LIBS=-lcutil -lcunit -lev$/;"	m
LOG	src/macros.h	41;"	d
MALLOC	src/macros.h	55;"	d
MEMCMP	src/macros.h	60;"	d
MEMCPY	src/macros.h	59;"	d
MEMSET	src/macros.h	61;"	d
MISSING_64BIT_ENDIAN	src/macros.h	83;"	d
MISSING_STRNLEN	src/macros.h	82;"	d
MULTIPLE	tests/test_aiofd.c	33;"	d	file:
MULTIPLE	tests/test_array.c	33;"	d	file:
MULTIPLE	tests/test_child.c	33;"	d	file:
MULTIPLE	tests/test_hashtable.c	33;"	d	file:
NAME	src/Makefile	/^NAME=cutil$/;"	m
NODE_AT	src/array.c	42;"	d	file:
NOTICE	src/macros.h	40;"	d
NO_ARGS	src/child.h	23;"	d
OBJ	src/Makefile	/^OBJ=$(SRC:.c=.o)$/;"	m
OBJ	tests/Makefile	/^OBJ=$(SRC:.c=.o)$/;"	m
OPEN_MAX	src/sanitize.c	37;"	d	file:
OUT	src/Makefile	/^OUT=lib$(NAME).a$/;"	m
OUT	tests/Makefile	/^OUT=test_all$/;"	m
PORTABLE_32_BIT	src/macros.h	75;"	d
PORTABLE_64_BIT	src/macros.h	71;"	d
PREFIX	src/Makefile	/^PREFIX?=\/usr\/local$/;"	m
REALLOC	src/macros.h	57;"	d
REPEAT	tests/test_aiofd.c	31;"	d	file:
REPEAT	tests/test_array.c	31;"	d	file:
REPEAT	tests/test_child.c	31;"	d	file:
REPEAT	tests/test_hashtable.c	31;"	d	file:
REPORTDIRS	Makefile	/^REPORTDIRS = $(DIRS:%=report-%)$/;"	m
SHELL	Makefile	/^SHELL=\/bin\/sh$/;"	m
SHELL	src/Makefile	/^SHELL=\/bin\/sh$/;"	m
SHELL	tests/Makefile	/^SHELL=\/bin\/sh$/;"	m
SIZEMAX	tests/test_aiofd.c	32;"	d	file:
SIZEMAX	tests/test_array.c	32;"	d	file:
SIZEMAX	tests/test_child.c	32;"	d	file:
SIZEMAX	tests/test_hashtable.c	32;"	d	file:
SOCKET_BADHOSTNAME	src/socket.h	/^    SOCKET_BADHOSTNAME  = -3,$/;"	e	enum:socket_ret_e
SOCKET_BADPARAM	src/socket.h	/^    SOCKET_BADPARAM     = -2,$/;"	e	enum:socket_ret_e
SOCKET_CONNECTED	src/socket.h	/^	SOCKET_CONNECTED    = -7$/;"	e	enum:socket_ret_e
SOCKET_ERROR	src/socket.h	/^    SOCKET_ERROR        = -1,$/;"	e	enum:socket_ret_e
SOCKET_INPUT	src/socket.h	/^    SOCKET_INPUT        = 2,$/;"	e	enum:socket_ret_e
SOCKET_INVALIDPORT	src/socket.h	/^    SOCKET_INVALIDPORT  = -4,$/;"	e	enum:socket_ret_e
SOCKET_OK	src/socket.h	/^    SOCKET_OK           = 1,$/;"	e	enum:socket_ret_e
SOCKET_OUTPUT	src/socket.h	/^    SOCKET_OUTPUT       = 3,$/;"	e	enum:socket_ret_e
SOCKET_POLLERR	src/socket.h	/^    SOCKET_POLLERR      = -6,$/;"	e	enum:socket_ret_e
SOCKET_SCTP	src/socket.h	/^    SOCKET_SCTP$/;"	e	enum:socket_type_e
SOCKET_TCP	src/socket.h	/^    SOCKET_TCP,$/;"	e	enum:socket_type_e
SOCKET_TIMEOUT	src/socket.h	/^    SOCKET_TIMEOUT      = -5,$/;"	e	enum:socket_ret_e
SOCKET_UDP	src/socket.h	/^    SOCKET_UDP,$/;"	e	enum:socket_type_e
SRC	src/Makefile	/^SRC=aiofd.c array.c  bitset.c btree.c buffer.c child.c daemon.c events.c hashtable.c log.c pair.c privileges.c sanitize.c socket.c$/;"	m
SRC	tests/Makefile	/^SRC=test_all.c test_aiofd.c test_array.c test_bitset.c test_btree.c test_buffer.c test_child.c test_hashtable.c test_pair.c$/;"	m
STRDUP	src/macros.h	62;"	d
SUITE	tests/test_all.c	30;"	d	file:
SUITE_VAR	tests/test_all.c	31;"	d	file:
T	src/macros.h	65;"	d
TESTDIRS	Makefile	/^TESTDIRS = $(DIRS:%=test-%)$/;"	m
TRUE	src/macros.h	32;"	d
UNINSTALLDIRS	Makefile	/^UNINSTALLDIRS = $(DIRS:%=uninstall-%)$/;"	m
UT	src/macros.h	66;"	d
WARN	src/macros.h	39;"	d
_GNU_SOURCE	src/log.c	17;"	d	file:
__AIOFD_H__	src/aiofd.h	18;"	d
__ARRAY_H__	src/array.h	18;"	d
__BITSET_H__	src/bitset.h	18;"	d
__BTREE_H__	src/btree.h	18;"	d
__BUFFER_H__	src/buffer.h	18;"	d
__CHILD_H__	src/child.h	18;"	d
__DAEMON_H__	src/daemon.h	18;"	d
__EVENTS_H__	src/events.h	18;"	d
__HASHTABLE_H__	src/hashtable.h	18;"	d
__LOG_H__	src/log.h	18;"	d
__MACROS_H__	src/macros.h	18;"	d
__PAIR_H__	src/pair.h	18;"	d
__PRIVILEGES_H__	src/privileges.h	18;"	d
__SANITIZE_H__	src/sanitize.h	18;"	d
__SOCKET_H__	src/socket.h	18;"	d
add_aiofd_test_suite	tests/test_aiofd.c	/^CU_pSuite add_aiofd_test_suite()$/;"	f
add_aiofd_tests	tests/test_aiofd.c	/^static CU_pSuite add_aiofd_tests( CU_pSuite pSuite )$/;"	f	file:
add_array_test_suite	tests/test_array.c	/^CU_pSuite add_array_test_suite()$/;"	f
add_array_tests	tests/test_array.c	/^static CU_pSuite add_array_tests( CU_pSuite pSuite )$/;"	f	file:
add_bitset_test_suite	tests/test_bitset.c	/^CU_pSuite add_bitset_test_suite()$/;"	f
add_bitset_tests	tests/test_bitset.c	/^static CU_pSuite add_bitset_tests( CU_pSuite pSuite )$/;"	f	file:
add_btree_test_suite	tests/test_btree.c	/^CU_pSuite add_btree_test_suite()$/;"	f
add_btree_tests	tests/test_btree.c	/^static CU_pSuite add_btree_tests( CU_pSuite pSuite )$/;"	f	file:
add_buffer_test_suite	tests/test_buffer.c	/^CU_pSuite add_buffer_test_suite()$/;"	f
add_buffer_tests	tests/test_buffer.c	/^static CU_pSuite add_buffer_tests( CU_pSuite pSuite )$/;"	f	file:
add_child_test_suite	tests/test_child.c	/^CU_pSuite add_child_test_suite()$/;"	f
add_child_tests	tests/test_child.c	/^static CU_pSuite add_child_tests( CU_pSuite pSuite )$/;"	f	file:
add_hashtable_test_suite	tests/test_hashtable.c	/^CU_pSuite add_hashtable_test_suite()$/;"	f
add_hashtable_tests	tests/test_hashtable.c	/^static CU_pSuite add_hashtable_tests( CU_pSuite pSuite )$/;"	f	file:
add_pair_test_suite	tests/test_pair.c	/^CU_pSuite add_pair_test_suite()$/;"	f
add_pair_tests	tests/test_pair.c	/^static CU_pSuite add_pair_tests( CU_pSuite pSuite )$/;"	f	file:
addr	src/socket.c	/^	IPv4			addr;			\/* IPv4 struct from host string *\/$/;"	m	struct:socket_s	file:
aiofd	src/child.c	/^	aiofd_t			aiofd;			\/* the fd management state *\/$/;"	m	struct:child_process_s	file:
aiofd	src/socket.c	/^	aiofd_t			aiofd;			\/* the fd management state *\/$/;"	m	struct:socket_s	file:
aiofd	tests/test_all.c	/^SUITE( aiofd );$/;"	v
aiofd_deinitialize	src/aiofd.c	/^void aiofd_deinitialize( aiofd_t * const aiofd )$/;"	f
aiofd_delete	src/aiofd.c	/^void aiofd_delete( void * aio )$/;"	f
aiofd_enable_read_evt	src/aiofd.c	/^int aiofd_enable_read_evt( aiofd_t * const aiofd,$/;"	f
aiofd_enable_write_evt	src/aiofd.c	/^int aiofd_enable_write_evt( aiofd_t * const aiofd,$/;"	f
aiofd_flush	src/aiofd.c	/^int aiofd_flush( aiofd_t * const aiofd )$/;"	f
aiofd_initialize	src/aiofd.c	/^int aiofd_initialize( aiofd_t * const aiofd, $/;"	f
aiofd_new	src/aiofd.c	/^aiofd_t * aiofd_new( int const write_fd,$/;"	f
aiofd_ops_s	src/aiofd.h	/^	struct aiofd_ops_s$/;"	s	struct:aiofd_s
aiofd_ops_t	src/aiofd.h	/^typedef struct aiofd_ops_s aiofd_ops_t;$/;"	t	typeref:struct:aiofd_ops_s
aiofd_read	src/aiofd.c	/^int32_t aiofd_read( aiofd_t * const aiofd,$/;"	f
aiofd_read_fn	src/aiofd.c	/^static evt_ret_t aiofd_read_fn( evt_loop_t * const el,$/;"	f	file:
aiofd_s	src/aiofd.h	/^struct aiofd_s$/;"	s
aiofd_t	src/aiofd.h	/^typedef struct aiofd_s aiofd_t;$/;"	t	typeref:struct:aiofd_s
aiofd_write	src/aiofd.c	/^int aiofd_write( aiofd_t * const aiofd, $/;"	f
aiofd_write_common	src/aiofd.c	/^static int aiofd_write_common( aiofd_t* const aiofd, $/;"	f	file:
aiofd_write_fn	src/aiofd.c	/^static evt_ret_t aiofd_write_fn( evt_loop_t * const el,$/;"	f	file:
aiofd_write_s	src/aiofd.c	/^typedef struct aiofd_write_s$/;"	s	file:
aiofd_write_t	src/aiofd.c	/^} aiofd_write_t;$/;"	t	typeref:struct:aiofd_write_s	file:
aiofd_writev	src/aiofd.c	/^int aiofd_writev( aiofd_t * const aiofd,$/;"	f
array	tests/test_all.c	/^SUITE( array );$/;"	v
array_clear	src/array.c	/^void array_clear( array_t * const array )$/;"	f
array_deinitialize	src/array.c	/^void array_deinitialize(array_t * const array)$/;"	f
array_delete	src/array.c	/^void array_delete( void * arr )$/;"	f
array_force_grow	src/array.c	/^void array_force_grow( array_t * const array )$/;"	f
array_get_free_node	src/array.c	/^static array_itr_t array_get_free_node( array_t * const array )$/;"	f	file:
array_get_head	src/array.h	106;"	d
array_get_tail	src/array.h	107;"	d
array_grow	src/array.c	/^static int array_grow( array_t * const array )$/;"	f	file:
array_initialize	src/array.c	/^int array_initialize( array_t * const array, $/;"	f
array_itr_begin	src/array.c	/^array_itr_t array_itr_begin( array_t const * const array )$/;"	f
array_itr_end	src/array.c	/^array_itr_t array_itr_end( array_t const * const array )$/;"	f
array_itr_end_t	src/array.c	/^array_itr_t const array_itr_end_t = -1;$/;"	v
array_itr_get	src/array.c	/^void* array_itr_get($/;"	f
array_itr_head	src/array.h	72;"	d
array_itr_next	src/array.c	/^array_itr_t array_itr_next( array_t const * const array, array_itr_t const itr )$/;"	f
array_itr_prev	src/array.h	84;"	d
array_itr_rbegin	src/array.h	74;"	d
array_itr_rend	src/array.h	75;"	d
array_itr_rnext	src/array.c	/^array_itr_t array_itr_rnext( array_t const * const array, array_itr_t const itr )$/;"	f
array_itr_rprev	src/array.h	85;"	d
array_itr_t	src/array.h	/^typedef int_t array_itr_t;$/;"	t
array_itr_tail	src/array.c	/^array_itr_t array_itr_tail( array_t const * const array )$/;"	f
array_lock	src/array.c	/^void array_lock(array_t * const array)$/;"	f
array_mutex	src/array.c	/^pthread_mutex_t * array_mutex(array_t * const array)$/;"	f
array_new	src/array.c	/^array_t * array_new( int_t initial_capacity, delete_fn pfn )$/;"	f
array_node_s	src/array.c	/^struct array_node_s$/;"	s	file:
array_node_t	src/array.h	/^typedef struct array_node_s array_node_t;$/;"	t	typeref:struct:array_node_s
array_pop	src/array.c	/^array_itr_t array_pop($/;"	f
array_pop_head	src/array.h	99;"	d
array_pop_tail	src/array.h	100;"	d
array_push	src/array.c	/^int array_push($/;"	f
array_push_head	src/array.h	92;"	d
array_push_tail	src/array.h	93;"	d
array_put_free_node	src/array.c	/^static void array_put_free_node( array_t * const array, array_itr_t const itr )$/;"	f	file:
array_s	src/array.h	/^typedef struct array_s$/;"	s
array_sanity_check	src/array.c	/^static int array_sanity_check( array_t const * const array )$/;"	f	file:
array_set_fail_grow	src/array.c	/^void array_set_fail_grow( int fail )$/;"	f
array_size	src/array.c	/^int_t array_size( array_t const * const array )$/;"	f
array_t	src/array.h	/^} array_t;$/;"	t	typeref:struct:array_s
array_try_lock	src/array.c	/^int array_try_lock(array_t * const array)$/;"	f
array_unlock	src/array.c	/^void array_unlock(array_t * const array)$/;"	f
balance	src/btree.c	/^	int32_t balance;			\/* balance factor *\/$/;"	m	struct:node_s	file:
bits	src/bitset.h	/^	uint32_t * bits;$/;"	m	struct:bitset_s
bitset	tests/test_all.c	/^SUITE( bitset );$/;"	v
bitset_s	src/bitset.h	/^typedef struct bitset_s$/;"	s
bitset_t	src/bitset.h	/^} bitset_t;$/;"	t	typeref:struct:bitset_s
bset_clear	src/bitset.c	/^int bset_clear( bitset_t * const bset, size_t const bit )$/;"	f
bset_clear_all	src/bitset.c	/^void bset_clear_all( bitset_t * const bset )$/;"	f
bset_deinitialize	src/bitset.c	/^void bset_deinitialize( bitset_t * const bset )$/;"	f
bset_delete	src/bitset.c	/^void bset_delete( void * bset )$/;"	f
bset_initialize	src/bitset.c	/^void bset_initialize( bitset_t * const bset, size_t const num_bits )$/;"	f
bset_new	src/bitset.c	/^bitset_t * bset_new( size_t const num_bits )$/;"	f
bset_set	src/bitset.c	/^int bset_set( bitset_t * const bset, size_t const bit )$/;"	f
bset_set_all	src/bitset.c	/^void bset_set_all( bitset_t * const bset )$/;"	f
bset_test	src/bitset.c	/^int bset_test( bitset_t const * const bset, size_t const bit )$/;"	f
bt_add	src/btree.c	/^int bt_add( bt_t * const btree, $/;"	f
bt_add_more_nodes	src/btree.c	/^static void bt_add_more_nodes( bt_t * const btree )$/;"	f	file:
bt_balance_tree	src/btree.c	/^static node_t * bt_balance_tree( bt_t * const btree, node_t * n )$/;"	f	file:
bt_deinitialize	src/btree.c	/^static void bt_deinitialize(bt_t * const btree)$/;"	f	file:
bt_delete	src/btree.c	/^void bt_delete(void * bt)$/;"	f
bt_delete_fn	src/btree.h	/^typedef void (*bt_delete_fn)(void * value);$/;"	t
bt_find	src/btree.c	/^void * bt_find(bt_t * const btree, void * const key )$/;"	f
bt_find_node	src/btree.c	/^static node_t * bt_find_node( bt_t * const btree, void * const key )$/;"	f	file:
bt_find_tree_max	src/btree.c	/^static node_t * bt_find_tree_max( node_t * p )$/;"	f	file:
bt_find_tree_min	src/btree.c	/^static node_t * bt_find_tree_min( node_t * p )$/;"	f	file:
bt_get_mutex	src/btree.c	/^pthread_mutex_t * bt_get_mutex(bt_t * const btree)$/;"	f
bt_get_node	src/btree.c	/^static node_t * bt_get_node( node_t ** const nlist )$/;"	f	file:
bt_initialize	src/btree.c	/^static void bt_initialize$/;"	f	file:
bt_insert_node	src/btree.c	/^static int bt_insert_node( bt_t * const btree,$/;"	f	file:
bt_is_left_child	src/btree.c	/^static int bt_is_left_child( node_t * p, node_t * n )$/;"	f	file:
bt_itr_begin	src/btree.c	/^bt_itr_t bt_itr_begin(bt_t const * const btree)$/;"	f
bt_itr_end	src/btree.c	/^bt_itr_t bt_itr_end(bt_t const * const btree)$/;"	f
bt_itr_get	src/btree.c	/^void* bt_itr_get(bt_t const * const btree, bt_itr_t const itr)$/;"	f
bt_itr_get_key	src/btree.c	/^void* bt_itr_get_key(bt_t const * const btree, bt_itr_t const itr)$/;"	f
bt_itr_next	src/btree.c	/^bt_itr_t bt_itr_next(bt_t const * const btree, bt_itr_t const itr)$/;"	f
bt_itr_rbegin	src/btree.c	/^bt_itr_t bt_itr_rbegin(bt_t const * const btree)$/;"	f
bt_itr_rend	src/btree.c	/^bt_itr_t bt_itr_rend(bt_t const * const btree)$/;"	f
bt_itr_rnext	src/btree.c	/^bt_itr_t bt_itr_rnext(bt_t const * const btree, bt_itr_t const itr)$/;"	f
bt_itr_t	src/btree.h	/^typedef void * bt_itr_t;$/;"	t
bt_key_cmp_fn	src/btree.h	/^typedef int (*bt_key_cmp_fn)( void * l, void * r);$/;"	t
bt_lock	src/btree.c	/^void bt_lock(bt_t * const btree)$/;"	f
bt_new	src/btree.c	/^bt_t* bt_new$/;"	f
bt_print	src/btree.c	/^void bt_print( bt_t * const btree )$/;"	f
bt_print_node	src/btree.c	/^void bt_print_node( node_t * const p, int const indent )$/;"	f
bt_put_node	src/btree.c	/^static void bt_put_node( node_t ** const nlist, node_t * const node )$/;"	f	file:
bt_remove	src/btree.c	/^void * bt_remove(bt_t * const btree, void * const key )$/;"	f
bt_replace_node	src/btree.c	/^static node_t * bt_replace_node( node_t * p, node_t * s )$/;"	f	file:
bt_rotate_left	src/btree.c	/^static node_t * bt_rotate_left( node_t * const p )$/;"	f	file:
bt_rotate_left_right	src/btree.c	/^static node_t * bt_rotate_left_right( node_t * const p )$/;"	f	file:
bt_rotate_right	src/btree.c	/^static node_t * bt_rotate_right( node_t * const p )$/;"	f	file:
bt_rotate_right_left	src/btree.c	/^static node_t * bt_rotate_right_left( node_t * const p )$/;"	f	file:
bt_s	src/btree.c	/^struct bt_s$/;"	s	file:
bt_size	src/btree.c	/^uint_t bt_size(bt_t * const btree)$/;"	f
bt_t	src/btree.h	/^typedef struct bt_s bt_t;$/;"	t	typeref:struct:bt_s
bt_try_lock	src/btree.c	/^int bt_try_lock(bt_t * const btree)$/;"	f
bt_unlock	src/btree.c	/^void bt_unlock(bt_t * const btree)$/;"	f
btree	tests/test_all.c	/^SUITE( btree );$/;"	v
buf	tests/test_buffer.c	/^int8_t const * const buf = "blah";$/;"	v
buffer	tests/test_all.c	/^SUITE( buffer );$/;"	v
buffer_delete	src/buffer.c	/^void buffer_delete( void * b )$/;"	f
buffer_new	src/buffer.c	/^buffer_t * buffer_new( void * p, size_t size, int weak )$/;"	f
buffer_s	src/buffer.c	/^struct buffer_s$/;"	s	file:
buffer_size	src/array.h	/^	int_t			buffer_size;			\/* number of slots in the node array *\/$/;"	m	struct:array_s
buffer_t	src/buffer.h	/^typedef struct buffer_s buffer_t;$/;"	t	typeref:struct:buffer_s
build_clean_environ	src/sanitize.c	/^int8_t ** build_clean_environ( int preservec, int8_t ** preservev, int addc, int8_t ** addv )$/;"	f
callback	src/events.h	/^	evt_fn			callback;$/;"	m	struct:evt_s
child	src/events.h	/^	struct ev_child		child;$/;"	m	union:ev_data_u	typeref:struct:ev_data_u::ev_child
child	tests/test_all.c	/^SUITE( child );$/;"	v
child_aiofd_error_fn	src/child.c	/^static int child_aiofd_error_fn( aiofd_t * const aiofd,$/;"	f	file:
child_aiofd_read_fn	src/child.c	/^static int child_aiofd_read_fn( aiofd_t * const aiofd,$/;"	f	file:
child_aiofd_write_fn	src/child.c	/^static int child_aiofd_write_fn( aiofd_t * const aiofd,$/;"	f	file:
child_ops_s	src/child.h	/^typedef struct child_ops_s $/;"	s
child_ops_t	src/child.h	/^} child_ops_t;$/;"	t	typeref:struct:child_ops_s
child_params	src/events.h	/^	} child_params;$/;"	m	union:evt_params_u	typeref:struct:evt_params_u::__anon2
child_process_deinitialize	src/child.c	/^static void child_process_deinitialize( child_process_t * const child, int wait )$/;"	f	file:
child_process_delete	src/child.c	/^void child_process_delete( void * cp, int wait )$/;"	f
child_process_flush	src/child.c	/^int child_process_flush( child_process_t * const cp )$/;"	f
child_process_get_pid	src/child.c	/^pid_t child_process_get_pid( child_process_t * const cp )$/;"	f
child_process_initialize	src/child.c	/^static int child_process_initialize( child_process_t * const child,$/;"	f	file:
child_process_new	src/child.c	/^child_process_t * child_process_new( int8_t const * const path,$/;"	f
child_process_read	src/child.c	/^int32_t child_process_read( child_process_t * const cp, $/;"	f
child_process_s	src/child.c	/^struct child_process_s$/;"	s	file:
child_process_t	src/child.h	/^typedef struct child_process_s child_process_t;$/;"	t	typeref:struct:child_process_s
child_process_write	src/child.c	/^int child_process_write( child_process_t * const cp, $/;"	f
child_process_writev	src/child.c	/^int child_process_writev( child_process_t * const cp,$/;"	f
clean_environ	src/sanitize.c	/^static int8_t * clean_environ[] =$/;"	v	file:
connect_fn	src/socket.h	/^	socket_ret_t (*connect_fn)( socket_t * const s, void * user_data );$/;"	m	struct:socket_ops_s
connected	src/socket.c	/^	int32_t			connected;		\/* is the socket connected? *\/$/;"	m	struct:socket_s	file:
daemonize	src/daemon.c	/^void daemonize( int8_t const * const root_dir )$/;"	f
data	src/aiofd.c	/^	void * data;$/;"	m	struct:aiofd_write_s	file:
data	src/array.c	/^	void *	data;	\/* pointer to the data *\/$/;"	m	struct:array_node_s	file:
data_head	src/array.h	/^	int_t			data_head;				\/* head node of the data circular list *\/$/;"	m	struct:array_s
default_key_cmp	src/btree.c	/^static int default_key_cmp( void * l, void * r )$/;"	f	file:
default_key_eq	src/hashtable.c	/^static int default_key_eq(void const * const l, void const * const r)$/;"	f	file:
default_key_hash	src/hashtable.c	/^static uint_t default_key_hash(void const * const key)$/;"	f	file:
default_load_factor	src/hashtable.c	/^float const default_load_factor = 0.65f;$/;"	v
deinit_aiofd_suite	tests/test_aiofd.c	/^static int deinit_aiofd_suite( void )$/;"	f	file:
deinit_array_suite	tests/test_array.c	/^static int deinit_array_suite( void )$/;"	f	file:
deinit_bitset_suite	tests/test_bitset.c	/^static int deinit_bitset_suite( void )$/;"	f	file:
deinit_btree_suite	tests/test_btree.c	/^static int deinit_btree_suite( void )$/;"	f	file:
deinit_buffer_suite	tests/test_buffer.c	/^static int deinit_buffer_suite( void )$/;"	f	file:
deinit_child_suite	tests/test_child.c	/^static int deinit_child_suite( void )$/;"	f	file:
deinit_hashtable_suite	tests/test_hashtable.c	/^static int deinit_hashtable_suite( void )$/;"	f	file:
deinit_pair_suite	tests/test_pair.c	/^static int deinit_pair_suite( void )$/;"	f	file:
delete_fn	src/array.h	/^typedef void (*delete_fn)(void*);$/;"	t
disconnect_fn	src/socket.h	/^	socket_ret_t (*disconnect_fn)( socket_t * const s, void * user_data );$/;"	m	struct:socket_ops_s
drop_privileges	src/privileges.c	/^void drop_privileges( int permanent )$/;"	f
dummy	src/array.c	/^	uint_t	dummy;$/;"	m	struct:array_node_s	file:
dynamic_key_eq	tests/test_hashtable.c	/^static int dynamic_key_eq(void const * const l, void const * const r)$/;"	f	file:
dynamic_key_hash	tests/test_hashtable.c	/^static uint_t dynamic_key_hash(void const * const key)$/;"	f	file:
el	src/aiofd.h	/^	evt_loop_t*	el;				\/* event loop we registered out evt with *\/$/;"	m	struct:aiofd_s
el	src/events.h	/^	evt_loop_t *	el;			\/* the event loop associated wtih *\/$/;"	m	struct:evt_s
el	tests/test_aiofd.c	/^static evt_loop_t * el = NULL;$/;"	v	file:
el	tests/test_child.c	/^static evt_loop_t * el = NULL;$/;"	v	file:
error_fn	src/aiofd.h	/^		int (*error_fn)( aiofd_t * const aiofd, int err, void * user_data );$/;"	m	struct:aiofd_s::aiofd_ops_s
error_fn	src/socket.h	/^	socket_ret_t (*error_fn)( socket_t * const s, int err, void * user_data );$/;"	m	struct:socket_ops_s
error_fn	tests/test_aiofd.c	/^static int error_fn( aiofd_t * const aiofd, int err, void * user_data )$/;"	f	file:
ev	src/events.h	/^	ev_data_t		ev;			\/* MUST BE FIRST *\/$/;"	m	struct:evt_s
ev_data_t	src/events.h	/^} ev_data_t;$/;"	t	typeref:union:ev_data_u
ev_data_u	src/events.h	/^typedef union ev_data_u$/;"	u
evt_child_callback	src/events.c	/^static void evt_child_callback( struct ev_loop * loop,$/;"	f	file:
evt_deinitialize_event_handler	src/events.c	/^void evt_deinitialize_event_handler( evt_t * const evt )$/;"	f
evt_delete	src/events.c	/^void evt_delete(void * e)$/;"	f
evt_delete_event_handler	src/events.c	/^void evt_delete_event_handler( void * e )$/;"	f
evt_fn	src/events.h	/^typedef evt_ret_t (*evt_fn)( evt_loop_t * const el,$/;"	t
evt_initialize_event_handler	src/events.c	/^int evt_initialize_event_handler( evt_t * const evt,$/;"	f
evt_io_callback	src/events.c	/^static void evt_io_callback( struct ev_loop * loop,$/;"	f	file:
evt_io_type_e	src/events.h	/^typedef enum evt_io_type_e$/;"	g
evt_io_type_t	src/events.h	/^} evt_io_type_t;$/;"	t	typeref:enum:evt_io_type_e
evt_log_backend	src/events.c	/^static void evt_log_backend( evt_loop_t * const el )$/;"	f	file:
evt_loop_t	src/events.h	/^typedef struct ev_loop evt_loop_t;$/;"	t	typeref:struct:ev_loop
evt_new	src/events.c	/^evt_loop_t* evt_new( void )$/;"	f
evt_new_event_handler	src/events.c	/^evt_t * evt_new_event_handler( evt_type_t const t,$/;"	f
evt_params	src/events.h	/^	evt_params_t	evt_params;$/;"	m	struct:evt_s
evt_params_t	src/events.h	/^} evt_params_t;$/;"	t	typeref:union:evt_params_u
evt_params_u	src/events.h	/^typedef union evt_params_u$/;"	u
evt_ret_e	src/events.h	/^typedef enum evt_ret_e$/;"	g
evt_ret_t	src/events.h	/^} evt_ret_t;$/;"	t	typeref:enum:evt_ret_e
evt_run	src/events.c	/^evt_ret_t evt_run( evt_loop_t * const el )$/;"	f
evt_s	src/events.h	/^struct evt_s$/;"	s
evt_signal_callback	src/events.c	/^static void evt_signal_callback( struct ev_loop * loop,$/;"	f	file:
evt_start_event_handler	src/events.c	/^evt_ret_t evt_start_event_handler( evt_loop_t * const el,$/;"	f
evt_stop	src/events.c	/^evt_ret_t evt_stop( evt_loop_t * const el )$/;"	f
evt_stop_event_handler	src/events.c	/^evt_ret_t evt_stop_event_handler( evt_loop_t * const el,$/;"	f
evt_t	src/events.h	/^typedef struct evt_s evt_t;$/;"	t	typeref:struct:evt_s
evt_type	src/events.h	/^	evt_type_t		evt_type;$/;"	m	struct:evt_s
evt_type_e	src/events.h	/^typedef enum evt_type_e$/;"	g
evt_type_t	src/events.h	/^} evt_type_t;$/;"	t	typeref:enum:evt_type_e
exit_fn	src/child.h	/^	int (*exit_fn)( child_process_t * const cp, int rpid, int rstatus, void * user_data );$/;"	m	struct:child_ops_s
exit_fn	tests/test_child.c	/^static int exit_fn( child_process_t * const cp, int rpid, int rstatus, void * user_data )$/;"	f	file:
exited	src/child.c	/^	int				exited;			\/* have we received the SIGCHLD signal? *\/$/;"	m	struct:child_process_s	file:
fail_grow	src/array.c	/^static int fail_grow = FALSE;$/;"	v	file:
fail_grow	src/hashtable.c	/^static int fail_grow = FALSE;$/;"	v	file:
fd	src/events.h	/^		int fd;$/;"	m	struct:evt_params_u::__anon3
first	src/pair.c	/^	void * first;$/;"	m	struct:pair_s	file:
first	tests/test_pair.c	/^int8_t const * const first = "first";$/;"	v
free_head	src/array.h	/^	int_t			free_head;				\/* head node of the free circular list *\/$/;"	m	struct:array_s
free_list	src/btree.c	/^	node_t*				free_list;	\/* list of free nodes *\/$/;"	m	struct:bt_s	file:
hash	src/hashtable.c	/^	uint_t				hash;				\/* cache the hash value *\/$/;"	m	struct:tuple_s	file:
hashtable	tests/test_all.c	/^SUITE( hashtable );$/;"	v
hashtable_primes	src/hashtable.c	/^uint_t const hashtable_primes[] =$/;"	v
host	src/socket.c	/^	int8_t*			host;			\/* host name *\/$/;"	m	struct:socket_s	file:
ht_add	src/hashtable.c	/^int ht_add( ht_t * const htable, $/;"	f
ht_add_prehash	src/hashtable.c	/^int ht_add_prehash( ht_t * const htable, $/;"	f
ht_clear	src/hashtable.c	/^int ht_clear(ht_t * const htable)$/;"	f
ht_compact	src/hashtable.c	/^int ht_compact( ht_t * const htable )$/;"	f
ht_deinitialize	src/hashtable.c	/^void ht_deinitialize( ht_t * const htable )$/;"	f
ht_delete	src/hashtable.c	/^void ht_delete(void * ht)$/;"	f
ht_delete_fn	src/hashtable.h	/^typedef void (*ht_delete_fn)(void * value);$/;"	t
ht_find	src/hashtable.c	/^ht_itr_t ht_find(ht_t const * const htable, void const * const key)$/;"	f
ht_find_index	src/hashtable.c	/^static ht_itr_t ht_find_index( ht_t const * const htable, $/;"	f	file:
ht_find_prehash	src/hashtable.c	/^ht_itr_t ht_find_prehash( ht_t const * const htable,$/;"	f
ht_force_grow	src/hashtable.c	/^void ht_force_grow( ht_t * const ht )$/;"	f
ht_free_tuples	src/hashtable.c	/^static void ht_free_tuples( ht_t * const htable )$/;"	f	file:
ht_get_mutex	src/hashtable.c	/^pthread_mutex_t * ht_get_mutex(ht_t * const htable)$/;"	f
ht_get_resize_load_factor	src/hashtable.c	/^float ht_get_resize_load_factor(ht_t const * const htable)$/;"	f
ht_grow	src/hashtable.c	/^static int ht_grow( ht_t * const htable, uint_t new_prime_index )$/;"	f	file:
ht_initialize	src/hashtable.c	/^int ht_initialize( ht_t * const htable, $/;"	f
ht_itr_begin	src/hashtable.c	/^ht_itr_t ht_itr_begin(ht_t const * const htable)$/;"	f
ht_itr_end	src/hashtable.c	/^ht_itr_t ht_itr_end(ht_t const * const htable)$/;"	f
ht_itr_end_t	src/hashtable.c	/^ht_itr_t const ht_itr_end_t = -1;$/;"	v
ht_itr_get	src/hashtable.c	/^void* ht_itr_get(ht_t const * const htable, ht_itr_t const itr, void** key)$/;"	f
ht_itr_next	src/hashtable.c	/^ht_itr_t ht_itr_next(ht_t const * const htable, ht_itr_t const itr)$/;"	f
ht_itr_rbegin	src/hashtable.c	/^ht_itr_t ht_itr_rbegin(ht_t const * const htable)$/;"	f
ht_itr_rend	src/hashtable.h	151;"	d
ht_itr_rnext	src/hashtable.c	/^ht_itr_t ht_itr_rnext(ht_t const * const htable, ht_itr_t const itr)$/;"	f
ht_itr_t	src/hashtable.h	/^typedef int_t ht_itr_t;$/;"	t
ht_load	src/hashtable.c	/^float ht_load(ht_t * const htable)$/;"	f
ht_lock	src/hashtable.c	/^void ht_lock(ht_t * const htable)$/;"	f
ht_needs_to_grow	src/hashtable.c	/^static int ht_needs_to_grow( ht_t const * const htable, $/;"	f	file:
ht_new	src/hashtable.c	/^ht_t* ht_new( uint_t initial_capacity, $/;"	f
ht_remove	src/hashtable.c	/^int ht_remove( ht_t * const htable, ht_itr_t const itr )$/;"	f
ht_s	src/hashtable.h	/^typedef struct ht_s$/;"	s
ht_set_fail_grow	src/hashtable.c	/^void ht_set_fail_grow( int fail )$/;"	f
ht_set_resize_load_factor	src/hashtable.c	/^int ht_set_resize_load_factor( ht_t * const htable, float load )$/;"	f
ht_size	src/hashtable.c	/^uint_t ht_size(ht_t * const htable)$/;"	f
ht_t	src/hashtable.h	/^} ht_t;$/;"	t	typeref:struct:ht_s
ht_try_lock	src/hashtable.c	/^int ht_try_lock(ht_t * const htable)$/;"	f
ht_unlock	src/hashtable.c	/^void ht_unlock(ht_t * const htable)$/;"	f
in_use	src/hashtable.c	/^	int_t				in_use;				\/* is the tuple in use? *\/$/;"	m	struct:tuple_s	file:
init_aiofd_suite	tests/test_aiofd.c	/^static int init_aiofd_suite( void )$/;"	f	file:
init_array_suite	tests/test_array.c	/^static int init_array_suite( void )$/;"	f	file:
init_bitset_suite	tests/test_bitset.c	/^static int init_bitset_suite( void )$/;"	f	file:
init_btree_suite	tests/test_btree.c	/^static int init_btree_suite( void )$/;"	f	file:
init_buffer_suite	tests/test_buffer.c	/^static int init_buffer_suite( void )$/;"	f	file:
init_child_suite	tests/test_child.c	/^static int init_child_suite( void )$/;"	f	file:
init_hashtable_suite	tests/test_hashtable.c	/^static int init_hashtable_suite( void )$/;"	f	file:
init_pair_suite	tests/test_pair.c	/^static int init_pair_suite( void )$/;"	f	file:
initial_capacity	src/array.h	/^	int_t			initial_capacity;		\/* the initial capacity value *\/$/;"	m	struct:array_s
initial_capacity	src/hashtable.h	/^	uint_t				initial_capacity;	\/* the initial capacity value *\/$/;"	m	struct:ht_s
int_less	tests/test_btree.c	/^static int int_less( void * l, void * r )$/;"	f	file:
int_t	src/macros.h	/^typedef int32_t int_t;$/;"	t
int_t	src/macros.h	/^typedef int64_t int_t;$/;"	t
io	src/events.h	/^	struct ev_io		io;$/;"	m	union:ev_data_u	typeref:struct:ev_data_u::ev_io
io_params	src/events.h	/^	} io_params;$/;"	m	union:evt_params_u	typeref:struct:evt_params_u::__anon3
iov	src/aiofd.c	/^	int iov;$/;"	m	struct:aiofd_write_s	file:
itr_end	src/btree.c	/^static const bt_itr_t itr_end = NULL;$/;"	v	file:
kcfn	src/btree.c	/^	bt_key_cmp_fn		kcfn;		\/* key compare function *\/$/;"	m	struct:bt_s	file:
kdfn	src/btree.c	/^	bt_delete_fn		kdfn;		\/* key delete function *\/$/;"	m	struct:bt_s	file:
kdfn	src/hashtable.h	/^	ht_delete_fn		kdfn;				\/* key delete function *\/$/;"	m	struct:ht_s
kefn	src/hashtable.h	/^	key_eq_fn			kefn;				\/* key compare function *\/$/;"	m	struct:ht_s
key	src/btree.c	/^	void * key;					\/* key *\/$/;"	m	struct:node_s	file:
key	src/hashtable.c	/^	void *				key;				\/* pointer to the key *\/$/;"	m	struct:tuple_s	file:
key_eq	tests/test_hashtable.c	/^static int key_eq( void const * const l, void const * const r )$/;"	f	file:
key_eq_fn	src/hashtable.h	/^typedef int (*key_eq_fn)(void const * const l, void const * const r);$/;"	t
key_hash	tests/test_hashtable.c	/^static uint_t key_hash( void const * const key )$/;"	f	file:
key_hash_fn	src/hashtable.h	/^typedef uint_t (*key_hash_fn)(void const * const key);$/;"	t
khfn	src/hashtable.h	/^	key_hash_fn			khfn;				\/* key hash function *\/$/;"	m	struct:ht_s
left	src/btree.c	/^	struct node_s * left;		\/* left child *\/$/;"	m	struct:node_s	typeref:struct:node_s::node_s	file:
list_size	src/btree.c	/^	uint_t				list_size;	\/* equal to initial capacity, size blocks in node_list *\/$/;"	m	struct:bt_s	file:
load_factor	src/hashtable.h	/^	float				load_factor;		\/* load level that triggers resize *\/$/;"	m	struct:ht_s
lock	src/array.h	/^	pthread_mutex_t lock;					\/* list lock *\/$/;"	m	struct:array_s
lock	src/btree.c	/^	pthread_mutex_t		lock;		\/* btree lock *\/$/;"	m	struct:bt_s	file:
lock	src/hashtable.h	/^	pthread_mutex_t		lock;				\/* hashtable lock *\/$/;"	m	struct:ht_s
log_fns	src/log.c	/^static cookie_io_functions_t log_fns =$/;"	v	file:
main	tests/test_all.c	/^int main()$/;"	f
max	src/btree.c	33;"	d	file:
min	src/btree.c	32;"	d	file:
next	src/array.c	/^	int_t	next;	\/* next node in the list *\/$/;"	m	struct:array_node_s	file:
next	src/btree.c	/^	struct node_s * next;		\/* traversal threading pointer\/free list pointer *\/$/;"	m	struct:node_s	typeref:struct:node_s::node_s	file:
nleft	src/aiofd.c	/^	size_t nleft;$/;"	m	struct:aiofd_write_s	file:
node_buffer	src/array.h	/^	array_node_t*	node_buffer;			\/* buffer of nodes *\/$/;"	m	struct:array_s
node_list	src/btree.c	/^	node_t**			node_list;	\/* memory for the nodes *\/$/;"	m	struct:bt_s	file:
node_s	src/btree.c	/^typedef struct node_s$/;"	s	file:
node_t	src/btree.c	/^} node_t;$/;"	t	typeref:struct:node_s	file:
noop	src/log.c	/^static int noop( void ) { return 0; }$/;"	f	file:
num_bits	src/bitset.h	/^	size_t num_bits;$/;"	m	struct:bitset_s
num_lists	src/btree.c	/^	uint_t				num_lists;	\/* number of blocks allocated *\/$/;"	m	struct:bt_s	file:
num_nodes	src/array.h	/^	int_t			num_nodes;				\/* number of nodes in the list *\/$/;"	m	struct:array_s
num_primes	src/hashtable.c	/^uint_t const num_primes = 30;$/;"	v
num_tuples	src/hashtable.h	/^	uint_t				num_tuples;			\/* number of tuples in the table *\/$/;"	m	struct:ht_s
open_devnull	src/sanitize.c	/^static int open_devnull( int fd )$/;"	f	file:
ops	src/aiofd.h	/^	}			ops;$/;"	m	struct:aiofd_s	typeref:struct:aiofd_s::aiofd_ops_s
ops	src/child.c	/^	child_ops_t		ops;			\/* child proces callbacks *\/$/;"	m	struct:child_process_s	file:
ops	src/socket.c	/^	socket_ops_t	ops;			\/* socket callbacks *\/$/;"	m	struct:socket_s	file:
orig_gid	src/privileges.c	/^static gid_t orig_gid = -1;$/;"	v	file:
orig_groups	src/privileges.c	/^static gid_t orig_groups[NGROUPS_MAX];$/;"	v	file:
orig_ngroups	src/privileges.c	/^static int orig_ngroups = -1;$/;"	v	file:
orig_uid	src/privileges.c	/^static uid_t orig_uid = -1;$/;"	v	file:
p	src/buffer.c	/^	void * p;$/;"	m	struct:buffer_s	file:
pair	tests/test_all.c	/^SUITE( pair );$/;"	v
pair_delete	src/pair.c	/^void pair_delete( void * p )$/;"	f
pair_first	src/pair.c	/^void * pair_first( pair_t const * const pair )$/;"	f
pair_new	src/pair.c	/^pair_t * pair_new( void * first, void * second )$/;"	f
pair_s	src/pair.c	/^struct pair_s$/;"	s	file:
pair_second	src/pair.c	/^void * pair_second( pair_t const * const pair )$/;"	f
pair_t	src/pair.h	/^typedef struct pair_s pair_t;$/;"	t	typeref:struct:pair_s
parent	src/btree.c	/^	struct node_s * parent;		\/* parent pointer *\/$/;"	m	struct:node_s	typeref:struct:node_s::node_s	file:
pfn	src/array.h	/^	delete_fn		pfn;					\/* destruction function for each node *\/$/;"	m	struct:array_s
pid	src/child.c	/^	pid_t			pid;			\/* the pid of the child process *\/$/;"	m	struct:child_process_s	file:
pid	src/daemon.c	/^pid_t pid, sid;$/;"	v
pid	src/events.h	/^		int pid;	\/* pid to watch *\/$/;"	m	struct:evt_params_u::__anon2
pint_less	tests/test_btree.c	/^static int pint_less( void * l, void * r )$/;"	f	file:
port	src/socket.c	/^	uint16_t		port;			\/* port number *\/$/;"	m	struct:socket_s	file:
preserve_environ	src/sanitize.c	/^static int8_t * preserve_environ[] =$/;"	v	file:
prev	src/array.c	/^	int_t	prev;	\/* prev node in the list *\/$/;"	m	struct:array_node_s	file:
prev	src/btree.c	/^	struct node_s * prev;		\/* traversal threading pointer *\/$/;"	m	struct:node_s	typeref:struct:node_s::node_s	file:
prime_index	src/hashtable.h	/^	uint_t				prime_index;		\/* the index of the table size *\/$/;"	m	struct:ht_s
priov	src/log.c	/^static int8_t * const priov[] =$/;"	v	file:
read_fn	src/aiofd.h	/^		int (*read_fn)( aiofd_t * const aiofd, size_t nread, void * user_data );$/;"	m	struct:aiofd_s::aiofd_ops_s
read_fn	src/child.h	/^	int32_t (*read_fn)( child_process_t * const cp, size_t nread, void * user_data );$/;"	m	struct:child_ops_s
read_fn	src/socket.h	/^	int32_t (*read_fn)( socket_t * const s, size_t nread, void * user_data );$/;"	m	struct:socket_ops_s
read_fn	tests/test_aiofd.c	/^static int read_fn( aiofd_t * const aiofd, size_t nread, void * user_data )$/;"	f	file:
read_fn	tests/test_child.c	/^static int32_t read_fn( child_process_t * const cp, size_t nread, void * user_data )$/;"	f	file:
restore_privileges	src/privileges.c	/^void restore_privileges( void )$/;"	f
revt	src/aiofd.h	/^	evt_t		revt;			\/* read event *\/$/;"	m	struct:aiofd_s
rfd	src/aiofd.h	/^	int			rfd;			\/* read fd if two are given *\/$/;"	m	struct:aiofd_s
right	src/btree.c	/^	struct node_s * right;		\/* right child *\/$/;"	m	struct:node_s	typeref:struct:node_s::node_s	file:
rpid	src/events.h	/^		int rpid;	\/* pid of process causing change *\/$/;"	m	struct:evt_params_u::__anon2
rstatus	src/events.h	/^		int rstatus;\/* status word of process, use macros from sys\/wait.h, waitpid *\/$/;"	m	struct:evt_params_u::__anon2
safe_fork	src/child.c	/^static pid_t safe_fork( void )$/;"	f	file:
sanitize_files	src/sanitize.c	/^void sanitize_files( void )$/;"	f
second	src/pair.c	/^	void * second;$/;"	m	struct:pair_s	file:
second	tests/test_pair.c	/^int8_t const * const second = "second";$/;"	v
sid	src/daemon.c	/^pid_t pid, sid;$/;"	v
sig	src/events.h	/^	struct ev_signal	sig;$/;"	m	union:ev_data_u	typeref:struct:ev_data_u::ev_signal
sigchld	src/child.c	/^	evt_t			sigchld;		\/* the SIGCHILD signal event handler *\/$/;"	m	struct:child_process_s	file:
sigchld_cb	src/child.c	/^static evt_ret_t sigchld_cb( evt_loop_t * const el,$/;"	f	file:
signal_params	src/events.h	/^	} signal_params;$/;"	m	union:evt_params_u	typeref:struct:evt_params_u::__anon1
signum	src/events.h	/^		int signum;$/;"	m	struct:evt_params_u::__anon1
size	src/aiofd.c	/^	size_t size;$/;"	m	struct:aiofd_write_s	file:
size	src/btree.c	/^	uint_t				size;		\/* number of nodes in the tree *\/$/;"	m	struct:bt_s	file:
size	src/buffer.c	/^	size_t size;$/;"	m	struct:buffer_s	file:
size	tests/test_buffer.c	/^size_t const size = 5;$/;"	v
socket_aiofd_error_fn	src/socket.c	/^static int socket_aiofd_error_fn( aiofd_t * const aiofd,$/;"	f	file:
socket_aiofd_read_fn	src/socket.c	/^static int socket_aiofd_read_fn( aiofd_t * const aiofd,$/;"	f	file:
socket_aiofd_write_fn	src/socket.c	/^static int socket_aiofd_write_fn( aiofd_t * const aiofd,$/;"	f	file:
socket_connect	src/socket.c	/^socket_ret_t socket_connect( socket_t* const s, $/;"	f
socket_deinitialize	src/socket.c	/^static void socket_deinitialize( socket_t * const s )$/;"	f	file:
socket_delete	src/socket.c	/^void socket_delete( void * s )$/;"	f
socket_disconnect	src/socket.c	/^socket_ret_t socket_disconnect( socket_t* const s )$/;"	f
socket_flush	src/socket.c	/^socket_ret_t socket_flush( socket_t* const s )$/;"	f
socket_initialize	src/socket.c	/^static void socket_initialize( socket_t * const s,$/;"	f	file:
socket_is_connected	src/socket.c	/^int socket_is_connected( socket_t* const s )$/;"	f
socket_lookup_host	src/socket.c	/^static socket_ret_t socket_lookup_host( socket_t * const s, $/;"	f	file:
socket_new	src/socket.c	/^socket_t* socket_new( socket_type_t const type, $/;"	f
socket_ops_s	src/socket.h	/^typedef struct socket_ops_s $/;"	s
socket_ops_t	src/socket.h	/^} socket_ops_t;$/;"	t	typeref:struct:socket_ops_s
socket_read	src/socket.c	/^int32_t socket_read( socket_t* const s, $/;"	f
socket_ret_e	src/socket.h	/^typedef enum socket_ret_e$/;"	g
socket_ret_t	src/socket.h	/^} socket_ret_t;$/;"	t	typeref:enum:socket_ret_e
socket_s	src/socket.c	/^struct socket_s$/;"	s	file:
socket_t	src/socket.h	/^typedef struct socket_s socket_t;$/;"	t	typeref:struct:socket_s
socket_type_e	src/socket.h	/^typedef enum socket_type_e$/;"	g
socket_type_t	src/socket.h	/^} socket_type_t;$/;"	t	typeref:enum:socket_type_e
socket_write	src/socket.c	/^socket_ret_t socket_write( socket_t * const s,$/;"	f
socket_writev	src/socket.c	/^socket_ret_t socket_writev( socket_t * const s,$/;"	f
start_logging	src/log.c	/^void start_logging( void )$/;"	f
stop_logging	src/log.c	/^void stop_logging( void )$/;"	f
test_aiofd_newdel	tests/test_aiofd.c	/^static void test_aiofd_newdel( void )$/;"	f	file:
test_array_clear	tests/test_array.c	/^static void test_array_clear( void )$/;"	f	file:
test_array_clear_empty	tests/test_array.c	/^static void test_array_clear_empty( void )$/;"	f	file:
test_array_dynamic_grow	tests/test_array.c	/^static void test_array_dynamic_grow( void )$/;"	f	file:
test_array_empty_iterator	tests/test_array.c	/^static void test_array_empty_iterator( void )$/;"	f	file:
test_array_get_middle	tests/test_array.c	/^static void test_array_get_middle( void )$/;"	f	file:
test_array_init_fail	tests/test_array.c	/^static void test_array_init_fail( void )$/;"	f	file:
test_array_initdeinit	tests/test_array.c	/^static void test_array_initdeinit( void )$/;"	f	file:
test_array_new_fail	tests/test_array.c	/^static void test_array_new_fail( void )$/;"	f	file:
test_array_newdel	tests/test_array.c	/^static void test_array_newdel( void )$/;"	f	file:
test_array_pop_head_static	tests/test_array.c	/^static void test_array_pop_head_static( void )$/;"	f	file:
test_array_pop_middle	tests/test_array.c	/^static void test_array_pop_middle( void )$/;"	f	file:
test_array_pop_tail_static	tests/test_array.c	/^static void test_array_pop_tail_static( void )$/;"	f	file:
test_array_push_dynamic	tests/test_array.c	/^static void test_array_push_dynamic( void )$/;"	f	file:
test_array_push_fail	tests/test_array.c	/^static void test_array_push_fail( void )$/;"	f	file:
test_array_push_head	tests/test_array.c	/^static void test_array_push_head( void )$/;"	f	file:
test_array_push_head_1	tests/test_array.c	/^static void test_array_push_head_1( void )$/;"	f	file:
test_array_push_middle	tests/test_array.c	/^static void test_array_push_middle( void )$/;"	f	file:
test_array_push_tail	tests/test_array.c	/^static void test_array_push_tail( void )$/;"	f	file:
test_array_push_tail_1	tests/test_array.c	/^static void test_array_push_tail_1( void )$/;"	f	file:
test_array_push_zero_initial_size	tests/test_array.c	/^static void test_array_push_zero_initial_size( void )$/;"	f	file:
test_array_static_grow	tests/test_array.c	/^static void test_array_static_grow( void )$/;"	f	file:
test_bitset_clearall	tests/test_bitset.c	/^void test_bitset_clearall( void )$/;"	f
test_bitset_initdeinit	tests/test_bitset.c	/^void test_bitset_initdeinit( void )$/;"	f
test_bitset_maxsize	tests/test_bitset.c	/^void test_bitset_maxsize( void )$/;"	f
test_bitset_newdel	tests/test_bitset.c	/^void test_bitset_newdel( void )$/;"	f
test_bitset_patternbitclears	tests/test_bitset.c	/^void test_bitset_patternbitclears( void )$/;"	f
test_bitset_patternbitflips	tests/test_bitset.c	/^void test_bitset_patternbitflips( void )$/;"	f
test_bitset_randombitflips	tests/test_bitset.c	/^void test_bitset_randombitflips( void )$/;"	f
test_bitset_setall	tests/test_bitset.c	/^void test_bitset_setall( void )$/;"	f
test_bitset_zerosize	tests/test_bitset.c	/^void test_bitset_zerosize( void )$/;"	f
test_btree_iterator	tests/test_btree.c	/^void test_btree_iterator( void )$/;"	f
test_btree_newdel	tests/test_btree.c	/^void test_btree_newdel( void )$/;"	f
test_btree_random	tests/test_btree.c	/^void test_btree_random( void )$/;"	f
test_btree_random_default	tests/test_btree.c	/^void test_btree_random_default( void )$/;"	f
test_btree_random_duplicate	tests/test_btree.c	/^void test_btree_random_duplicate( void )$/;"	f
test_btree_random_dynamic	tests/test_btree.c	/^void test_btree_random_dynamic( void )$/;"	f
test_buffer_newdel	tests/test_buffer.c	/^void test_buffer_newdel( void )$/;"	f
test_buffer_newdel_weak	tests/test_buffer.c	/^void test_buffer_newdel_weak( void )$/;"	f
test_child_newdel	tests/test_child.c	/^static void test_child_newdel( void )$/;"	f	file:
test_hashtable_add_dynamic	tests/test_hashtable.c	/^static void test_hashtable_add_dynamic( void )$/;"	f	file:
test_hashtable_add_fail	tests/test_hashtable.c	/^static void test_hashtable_add_fail( void )$/;"	f	file:
test_hashtable_add_static	tests/test_hashtable.c	/^static void test_hashtable_add_static( void )$/;"	f	file:
test_hashtable_add_to_empty	tests/test_hashtable.c	/^static void test_hashtable_add_to_empty( void )$/;"	f	file:
test_hashtable_change_load_factor	tests/test_hashtable.c	/^static void test_hashtable_change_load_factor( void )$/;"	f	file:
test_hashtable_change_load_factor_fail	tests/test_hashtable.c	/^static void test_hashtable_change_load_factor_fail( void )$/;"	f	file:
test_hashtable_clear	tests/test_hashtable.c	/^static void test_hashtable_clear( void )$/;"	f	file:
test_hashtable_clear_empty	tests/test_hashtable.c	/^static void test_hashtable_clear_empty( void )$/;"	f	file:
test_hashtable_compact	tests/test_hashtable.c	/^static void test_hashtable_compact( void )$/;"	f	file:
test_hashtable_compact_fail	tests/test_hashtable.c	/^static void test_hashtable_compact_fail( void )$/;"	f	file:
test_hashtable_dynamic_grow	tests/test_hashtable.c	/^static void test_hashtable_dynamic_grow( void )$/;"	f	file:
test_hashtable_find_static	tests/test_hashtable.c	/^static void test_hashtable_find_static( void )$/;"	f	file:
test_hashtable_forward_itr	tests/test_hashtable.c	/^static void test_hashtable_forward_itr( void )$/;"	f	file:
test_hashtable_initdeinit_default_fns	tests/test_hashtable.c	/^static void test_hashtable_initdeinit_default_fns( void )$/;"	f	file:
test_hashtable_initdeinit_fail	tests/test_hashtable.c	/^static void test_hashtable_initdeinit_fail( void )$/;"	f	file:
test_hashtable_newdel_custom_key_fns	tests/test_hashtable.c	/^static void test_hashtable_newdel_custom_key_fns( void )$/;"	f	file:
test_hashtable_newdel_default_fns	tests/test_hashtable.c	/^static void test_hashtable_newdel_default_fns( void )$/;"	f	file:
test_hashtable_newdel_fail	tests/test_hashtable.c	/^static void test_hashtable_newdel_fail( void )$/;"	f	file:
test_hashtable_remove	tests/test_hashtable.c	/^static void test_hashtable_remove( void )$/;"	f	file:
test_hashtable_remove_dynamic	tests/test_hashtable.c	/^static void test_hashtable_remove_dynamic( void )$/;"	f	file:
test_hashtable_reverse_itr	tests/test_hashtable.c	/^static void test_hashtable_reverse_itr( void )$/;"	f	file:
test_hashtable_static_grow	tests/test_hashtable.c	/^static void test_hashtable_static_grow( void )$/;"	f	file:
test_pair_newdel	tests/test_pair.c	/^void test_pair_newdel( void )$/;"	f
test_pair_nulls	tests/test_pair.c	/^void test_pair_nulls( void )$/;"	f
trace	src/events.h	/^		int trace;	\/* 0 == only signal upon termination, 1 == also signal when stopped\/continued *\/$/;"	m	struct:evt_params_u::__anon2
tree	src/btree.c	/^	node_t*				tree;		\/* pointer to btree root *\/$/;"	m	struct:bt_s	file:
tuple_s	src/hashtable.c	/^struct tuple_s$/;"	s	file:
tuple_t	src/hashtable.h	/^typedef struct tuple_s tuple_t;$/;"	t	typeref:struct:tuple_s
tuples	src/hashtable.h	/^	tuple_t*			tuples;				\/* pointer to tuple table *\/$/;"	m	struct:ht_s
type	src/socket.c	/^	socket_type_t	type;			\/* type of socket *\/$/;"	m	struct:socket_s	file:
types	src/events.h	/^		evt_io_type_t types;$/;"	m	struct:evt_params_u::__anon3
uint_t	src/macros.h	/^typedef uint32_t uint_t;$/;"	t
uint_t	src/macros.h	/^typedef uint64_t uint_t;$/;"	t
user_data	src/aiofd.h	/^	void *		user_data;		\/* context to pass to callbacks *\/$/;"	m	struct:aiofd_s
user_data	src/child.c	/^	void *			user_data;		\/* passed to ops callbacks *\/$/;"	m	struct:child_process_s	file:
user_data	src/events.h	/^	void *			user_data;$/;"	m	struct:evt_s
user_data	src/socket.c	/^	void *			user_data;		\/* passed to ops callbacks *\/$/;"	m	struct:socket_s	file:
val	src/btree.c	/^	void * val;					\/* value *\/$/;"	m	struct:node_s	file:
value	src/hashtable.c	/^	void *				value;				\/* pointer to the value *\/$/;"	m	struct:tuple_s	file:
vdfn	src/btree.c	/^	bt_delete_fn		vdfn;		\/* value delete function *\/$/;"	m	struct:bt_s	file:
vdfn	src/hashtable.h	/^	ht_delete_fn		vdfn;				\/* value delete function *\/$/;"	m	struct:ht_s
wbuf	src/aiofd.h	/^	array_t		wbuf;			\/* array of buffers waiting to be written *\/$/;"	m	struct:aiofd_s
weak	src/buffer.c	/^	int weak;$/;"	m	struct:buffer_s	file:
wevt	src/aiofd.h	/^	evt_t		wevt;			\/* write event *\/$/;"	m	struct:aiofd_s
wfd	src/aiofd.h	/^	int			wfd;			\/* read\/write fd, if only one given, write-only otherwise *\/$/;"	m	struct:aiofd_s
write_fn	src/aiofd.h	/^		int (*write_fn)( aiofd_t * const aiofd, uint8_t const * const buffer, void * user_data );$/;"	m	struct:aiofd_s::aiofd_ops_s
write_fn	src/child.h	/^	int32_t (*write_fn)( child_process_t * const cp, uint8_t const * const buffer, void * user_data );$/;"	m	struct:child_ops_s
write_fn	src/socket.h	/^	int32_t (*write_fn)( socket_t * const s, uint8_t const * const buffer, void * user_data );$/;"	m	struct:socket_ops_s
write_fn	tests/test_aiofd.c	/^static int write_fn( aiofd_t * const aiofd, uint8_t const * const buffer, void * user_data )$/;"	f	file:
write_fn	tests/test_child.c	/^static int32_t write_fn( child_process_t * const cp, uint8_t const * const buffer, void * user_data )$/;"	f	file:
writefn	src/log.c	/^typedef int (*writefn)(void *, const char *, int);$/;"	t	file:
writer	src/log.c	/^static ssize_t writer( void * cookie, char const * data, size_t leng )$/;"	f	file:
